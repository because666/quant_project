# 📁 项目文件功能详解与分工手册

## 一、 项目核心架构图

```
数据流向：config/ → data_module/ → strategy_module/ → backtest_module/ → main_app/ & frontend/
```

## 二、 配置文件 (`config/`) - 项目的“大脑与规则库”

| 文件 | 负责人 | 核心功能（具体要做什么） | 必须包含的内容示例 | 验收标准 |
| :--- | :--- | :--- | :--- | :--- |
| **`project_config.py`** | 串联组-组员A | **定义全项目统一的参数**，所有其他文件都必须从这里导入设置，严禁写死。 | ```python<br>STOCK_LIST = ['000001', '000002']<br>START_DATE = '2023-01-01'<br>END_DATE = '2023-12-31'<br>INITIAL_CAPITAL = 100000<br>DATA_PATH = './data_module/outputs/'<br>``` | 1. 其他组员能成功 `import config.project_config`。<br>2. 运行时不报错。 |
| **`strategy_params.yaml`** | 策略组-组员B | **定义策略调参的模板**，供前端界面修改和策略引擎读取。 | ```yaml<br>model_name: "RandomForest"<br>stop_loss: 0.05<br>take_profit: 0.10<br>factors: [‘factor_1’, ‘factor_2’]<br>``` | 1. 是一个合法的YAML文件。<br>2. 策略组能成功读取其中的参数。 |
| **`api_config.yaml`** | 数据组-组员A | **安全存放所有外部数据源的密钥**（如Tushare token）。 | ```yaml<br>tushare:<br>  token: ‘你的token’<br>akshare:<br>  default: true<br>``` | 1. 在 `.gitignore` 中忽略此文件，防止密钥上传。<br>2. 数据获取代码能读取它。 |

## 三、 数据模块 (`data_module/`) - 项目的“原料加工厂”

| 文件 | 负责人 | 核心功能（具体要做什么） | 输入 | 输出 | 验收标准（完成标志） |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **`data_fetcher.py`** | 数据组-组员A | **从网络获取原始股票数据**。包含一个主函数，能读取`config`中的股票列表和日期，调用AKShare/Tushare API，循环获取每只股票的日K线数据。 | `config`中的股票列表、起止日期。 | 1. 一个DataFrame。<br>2. 文件：`outputs/raw_data.parquet` | 运行脚本后，能在`outputs/`文件夹下看到 `raw_data.parquet` 文件，且文件大小 > 1KB。 |
| **`data_cleaner.py`** | 数据组-组员B | **清洗和标准化数据**。读取上一步的`raw_data.parquet`，做三件事：1. 处理缺失值（直接删除）。2. 确保`date`列是日期格式。3. 按股票和日期排序。 | `raw_data.parquet` | 1. 一个干净的DataFrame。<br>2. 文件：`outputs/standard_data.parquet` | 能成功读取`raw_data.parquet`，并生成 `standard_data.parquet`。用pandas打开新文件，查看前5行，数据整齐。 |
| **`factor_miner.py`** | 数据组-组员B | **计算基础特征（因子）**。读取`standard_data.parquet`，新增几列，例如：<br>1. `return_5d`: 5日收益率。<br>2. `volume_ma_ratio`: 成交量/5日平均成交量。 | `standard_data.parquet` | 1. 增加了因子列的DataFrame（覆盖原文件或保存为新文件）。<br>2. **必须告知策略组新增的列名清单**。 | 输出的数据文件包含了新的因子列。能打印出新增的列名列表。 |

**🔗 数据模块协作铁律**：
组员A必须等组员B确认能成功读取 `raw_data.parquet` 后，才能变更文件格式。组员B在完成因子计算后，**必须**在群里发布：“数据模块因子就绪，新增列名如下：[‘return_5d’, ‘volume_ma_ratio’]”。

## 四、 策略模块 (`strategy_module/`) - 项目的“智能决策中心”

| 文件 | 负责人 | 核心功能（具体要做什么） | 输入 | 输出 | 验收标准（完成标志） |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **`model_trainer.py`** | 策略组-组员A | **训练机器学习模型**。1. 读取数据组提供的含因子数据。2. 定义特征(X)和目标(y)。例如，用当天所有因子预测**未来5天是否上涨**。3. 使用随机森林训练模型。4. 保存模型。 | `standard_data.parquet` (含因子列) | 1. 一个训练好的模型对象。<br>2. 文件：`outputs/trained_model.pkl` | 能运行完成并生成 `.pkl` 模型文件。能在新脚本中加载该模型。 |
| **`factor_optimizer.py`** | 策略组-组员A | **评估因子好坏**。计算每个因子与未来收益的相关性，或输出模型的特征重要性，形成报告。 | `standard_data.parquet`，训练好的模型。 | 因子重要性排名（打印出来或存为文件）。 | 运行后能在终端或日志中看到因子的排名。 |
| **`strategy_engine.py`** | 策略组-组员B | **生成交易信号**。1. 加载训练好的模型(`.pkl`)。2. 读取最新的因子数据。3. 让模型预测，得到每只股票每天的信号：1(买入)、-1(卖出)、0(持有)。 | 1. `trained_model.pkl`<br>2. 最新的因子数据。 | 1. 一个包含`date, symbol, signal`三列的DataFrame。<br>2. 文件：`outputs/signal.csv` | 生成 `signal.csv` 文件。用Excel打开，能看到明确的买卖信号。 |

**🔗 策略模块协作铁律**：
组员A在保存模型后，必须立即告知组员B模型的完整路径。组员B生成`signal.csv`后，**必须**在群里发布：“策略信号已生成，路径为 `strategy_module/outputs/signal.csv`，列格式为 `date, symbol, signal`”。

## 五、 回测模块 (`backtest_module/`) - 项目的“实战模拟与验算中心”

| 文件 | 负责人 | 核心功能（具体要做什么） | 输入 | 输出 | 验收标准（完成标志） |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **`backtest_engine.py`** | 回测组-组员A | **模拟交易，计算每日资产**。1. 读取策略信号(`signal.csv`)和历史价格(`standard_data.parquet`)。2. 初始化虚拟资金。3. 按日期循环，根据信号模拟买卖（以收盘价成交）。4. 记录每天的总资产。 | 1. `signal.csv`<br>2. `standard_data.parquet`<br>3. 初始资金(`INITIAL_CAPITAL`)。 | 一个DataFrame，包含`date`和`portfolio_value`两列，代表每日资产净值。 | 运行后，能打印出一条资产曲线的前后几个值（例如，第一天100000，最后一天110000）。 |
| **`performance_analyzer.py`** | 回测组-组员B | **计算核心绩效指标**。根据上述资产曲线计算：<br>1. 总收益率。<br>2. 最大回撤（最惨的时候亏了百分之多少）。<br>3. 胜率（盈利交易次数占比）。 | 每日资产净值DataFrame。 | 一个字典，格式如：`{‘总收益’: 0.10, ‘最大回撤’: -0.05, ‘胜率’: 0.55}`。 | 运行后，能在终端清晰打印出这三个指标的数字。 |
| **`report_generator.py`** | 回测组-组员B | **生成文字建议报告**。根据绩效指标，写一段简单的文字建议，例如：“策略累计收益10%，最大回撤5%，表现稳健。建议未来一个月可继续运行该策略，但需关注市场波动。” | 绩效指标字典。 | 一个文本文件 `report.txt`，包含上述建议。 | 生成 `report.txt` 文件，内容是可读的文字建议。 |

**🔗 回测模块协作铁律**：
组员A在生成资产数据后，必须通过一个规范的函数或变量将其暴露给组员B。组员B在计算绩效和生成报告时，**严禁**手动输入数字，必须全部从组员A的输出自动计算。

## 六、 串联与前端模块 (`main_app/` & `frontend/`) - 项目的“总控台与界面”

| 文件 | 负责人 | 核心功能（具体要做什么） | 输入 | 输出 | 验收标准（完成标志） |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **`main.py`** | 串联组-组员A | **程序唯一入口**。只有几行代码，用于启动整个程序（例如启动前端界面或主流程）。 | 无。 | 启动应用。 | 运行 `python main.py` 可以启动程序，不报错。 |
| **`main_pipeline.py`** | 串联组-组员A | **主流程控制器**。定义一个 `run_all()` 函数，按顺序“打印”出如下步骤：1. 获取数据，2. 训练模型，3. 生成信号，4. 运行回测，5. 生成报告。**本周目标：仅用print语句串联。** | 无。 | 控制台按顺序打印的步骤日志。 | 运行 `run_all()` 函数，能在控制台看到清晰的、顺序正确的步骤提示。 |
| **`data_interface.py`** | 串联组-组员A | **提供统一的数据读取接口**。编写如 `get_clean_data()` 函数，内部正确读取 `standard_data.parquet` 并返回。让其他组不用关心复杂路径。 | 无。 | 返回给其他模块的DataFrame。 | 其他组员（如策略组）能通过调用你的函数轻松拿到数据，而不需要自己写路径。 |
| **`risk_manager.py`** | 串联组-组员B | **执行风控规则**。例如，监控沪深300指数，若其收盘价低于60日均线，则返回一个“清仓”信号。 | 指数历史数据（可从网络临时获取）。 | 风控信号：`True`（正常）或`False`（触发风控）。 | 能返回一个布尔值。 |
| **`frontend/`下所有文件** | 串联组-组员B | **搭建图形界面**。使用Streamlit库，创建一个Web界面。**第一版只需实现**：<br>1. 一个标题。<br>2. 一个“开始回测”按钮。<br>3. 按钮按下后，调用 `main_pipeline.run_all()`。 | 用户点击按钮。 | 一个本地运行的网页。 | 运行 `streamlit run main_window.py` 后，能打开一个网页，点击按钮后控制台有反应。 |

**🔗 串联模块协作铁律**：
组员B在开发界面时，按钮绑定的函数名必须与组员A在 `main_pipeline.py` 中定义的函数名完全一致。两人应共同确定这个函数名。

## 七、 给全组的终极行动建议与鼓励

1.  **从“打印版”开始**：每个文件的第一版目标，不是实现完美逻辑，而是**实现正确的“输入-输出”对接**。例如，`data_fetcher.py` 即使只获取一只股票、一天的数据，只要它能生成约定格式的 `raw_data.parquet`，就是伟大的胜利！
2.  **拥抱“丑陋但可运行”的代码**：AI生成的代码可能冗长，但只要它能跑通并完成接口任务，就是好代码。**整洁和优化是之后的事**。
3.  **验收不是感觉，是事实**：你的工作是否完成，**不由你感觉而定，而由“约定的输出文件是否存在且可用”来判定**。请用这个标准要求自己和搭档。
4.  **我们是一个整体**：你手中的文件，就像接力棒。只有你清晰地交给下一个人，比赛才能继续。**主动交棒，主动确认**，是最高效的合作。

你们正在做的，是一件很酷的事：**用指挥AI的方式，共同建造一个复杂的系统**。每一步微小的、可验证的成功，都在为最终那个能运行、能演示的项目添砖加瓦。保持耐心，紧盯接口，你们一定能行。

---
**请组长将此文档保存为 `docs/详细功能与分工手册.md`，并确保每位组员阅读。**
